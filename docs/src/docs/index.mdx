---
title: docs
---

import { ToggleLayer, anchor } from "react-laag";
import Prop from "../components/PropDescription";
import GitHubButton from "react-github-btn";

[![NPM](https://img.shields.io/npm/v/react-laag.svg)](https://www.npmjs.com/package/react-laag)
[![TYPESCRIPT](https://img.shields.io/badge/%3C%2F%3E-typescript-blue)](http://www.typescriptlang.org/)
[![BUNDLEPHOBIA](https://badgen.net/bundlephobia/minzip/react-laag)](https://bundlephobia.com/result?p=react-laag)
[![Weekly downloads](https://badgen.net/npm/dw/react-laag)](https://badgen.net/npm/dw/react-laag)

<GitHubButton
  href="https://github.com/everweij/react-laag"
  data-show-count="true"
  aria-label="Star everweij/react-laag on GitHub"
>
  Star
</GitHubButton>

### Installation

To download react-laag run:

```bash
yarn add react-laag
```

### Top Features

- Build your own tooltips / dropdown-menu's / pop-overs / etc...
- Not opinionated regarding styling or animations
- Highly customizable
- Only ~5kb minified and gzipped
- Zero dependencies
- Built with typescript / ships with typescript definitions
- Integrates well with other libraries
- Automatically adjusts your layer's placement to fit the screen
- Works with nested scroll-containers
- Observes and reacts to changes in dimensions

### Browser compatibility

react-laag has been tested on all modern browsers and should also work in IE 11.

In order to watch elements for resizing, react-laag makes use of _ResizeObserver_. If your browser does not come with ResizeObserver out of the box, you can inject a polyfill via props, ie.:

```jsx
import ResizeObserver from "resize-observer-polyfill";
import { ToggleLayer } from "react-laag";

<ToggleLayer ResizeObserver={ResizeObserver} />;
```

### Server-side rendering

react-laag is fully compatible with server-side rendering.

# < ToggleLayer />

```jsx
import { ToggleLayer } from "react-laag";
```

ToggleLayer is the most important component of `react-laag`. As the name suggests, this component is used to toggle layers (between _show_ and _don't show_). It assumes there are two key components at play:

- a **trigger**, which can be any html-element
- a **layer**, the element we want to toggle, can also be any html-element

### position: relative;

react-laag expects you to style the scroll-parent where you want to contain your layer in `position: relative` (or `absolute` | `fixed`). If your layer does not need to be contained, because the trigger scrolls with the rest of the page for instance, you don't have to do anything, because react-laag looks at the `document.body` by default.

### Render props

In order to give you as much control as possible, react-laag makes use of the _render prop_ pattern; Instead of a normal react-element, react-laag expects you to pass in a function which in turn returns a react-element.
To illustrate:

```jsx
// Plain react-element...
<div />

// ...becomes
() => <div />
```

The cool thing about this is that react-laag provides you with tools, and you get to decide _if_ and _how_ to use them!

### Controlled vs. uncontrolled

By default react-laag behaves uncontrolled. That means that some state is managed internally inside react-laag. Most of the time this works fine, but there are cases where more control is desirable. Fortunately, react-laag watches certain props and can tell if you want to manage parts of the state yourself.

## Props

<Prop
  name="children()"
  required
  type={
    <>
      ( <Prop.Arg>props</Prop.Arg>: <Prop.Obj linked>ChildProps</Prop.Obj> ):{" "}
      <Prop.Obj>ReactNode</Prop.Obj>
    </>
  }
  misc={
    <>
      <Prop.TypeBox
        name="ChildProps"
        props={
          <>
            <Prop
              name="triggerRef"
              required
              type={<Prop.Obj>RefObject</Prop.Obj>}
              misc={
                <>
                  In order to calculate the layer's position, react-laag needs
                  access to the trigger's dom-element. Assign{" "}
                  <Prop.Ref>triggerRef</Prop.Ref> to the{" "}
                  <Prop.Ref>ref</Prop.Ref> prop when using a React-element or
                  Component (make sure that you the <Prop.Ref>ref</Prop.Ref> is
                  forwarded with <Prop.Ref>React.forwardRef</Prop.Ref>)
                </>
              }
            />
            <Prop
              name="isOpen"
              type={<Prop.Obj>boolean</Prop.Obj>}
              misc="Describes whether the layer is open or closed"
            />
            <Prop name="open()" type={<>(): void</>} misc="Shows the layer" />
            <Prop name="close()" type={<>(): void</>} misc="Hides the layer" />
            <Prop
              name="toggle()"
              type={<>(): void</>}
              misc="Toggles between show/hide"
            />
            <Prop
              name="layerSide"
              type={
                <>
                  <Prop.Obj>LayerSide</Prop.Obj> | <Prop.Obj>null</Prop.Obj>
                </>
              }
              misc={
                <>
                  <Prop.Ref>null</Prop.Ref> when the layer is closed.
                  <br />
                  When the layer is open, <Prop.Ref>layerSide</Prop.Ref>{" "}
                  describes on which side the layer is currently positioned
                  relative to the trigger. <br />
                  When <Prop.Ref>layerSide</Prop.Ref> is <Prop.Str as="span">
                    "center"
                  </Prop.Str>, it means that the layer is anchored <Prop.Str as="span">
                    "CENTER"
                  </Prop.Str>
                  <br />
                  <Prop.Obj as="span">LayerSide</Prop.Obj> = <Prop.Str as="span">
                    "top"
                  </Prop.Str> | <Prop.Str as="span">"right"</Prop.Str> | <Prop.Str as="span">
                    "bottom"
                  </Prop.Str> |<Prop.Str as="span">"left"</Prop.Str> | <Prop.Str as="span">"center"</Prop.Str>
                </>
              }
            />
          </>
        }
      />
    </>
  }
/>
<Prop
  name="renderLayer()"
  required
  type={
    <>
      ( <Prop.Arg>props</Prop.Arg>: <Prop.Obj linked>RenderLayerProps</Prop.Obj>{" "}
      ): <Prop.Obj>ReactNode</Prop.Obj>
    </>
  }
  misc={
    <>
      <Prop.TypeBox
        name="RenderLayerProps"
        props={
          <>
            <Prop
              name="layerProps"
              required
              type={
                <>
                  {"{ "}ref: <Prop.Obj>RefObject</Prop.Obj>, style:{" "}
                  <Prop.Obj>CSSProperties</Prop.Obj>
                  {" }"}
                </>
              }
              misc={
                <>
                  In some cases you can spread these{" "}
                  <Prop.Ref>layerProps</Prop.Ref> directly onto your component
                  or element like so: <br />
                  <Prop.Ref>{"<div {...layerProps} />"}</Prop.Ref>
                  <br />
                  <br />
                  But sometimes you want to add styles on top of the
                  style-object react-laag provides. Such scenario's can be
                  handled like this:
                  <br />
                  <Prop.Ref>
                    {
                      "<div ref={layerProps.ref} style={{ ...layerProps.style, backgroundColor: 'blue'}} />"
                    }
                  </Prop.Ref>
                </>
              }
            />
            <Prop
              name="isOpen"
              type={
                <>
                  <Prop.Obj>boolean</Prop.Obj>
                </>
              }
              misc={
                <>
                  Determines whether we should render the layer or not. The
                  reason for providing this prop, and not to ignore the{" "}
                  <Prop.Ref>renderLayer</Prop.Ref> prop entirely when{" "}
                  <Prop.Ref>isOpen</Prop.Ref> === <Prop.Bool>false</Prop.Bool>,
                  is that you still have control over what to do when the layer
                  is closed (ie. handling transitions / animations).
                </>
              }
            />
            <Prop
              name="layerSide"
              type={
                <>
                  <Prop.Obj>LayerSide</Prop.Obj> | <Prop.Obj>null</Prop.Obj>
                </>
              }
              misc={
                <>
                  <Prop.Ref>null</Prop.Ref> when the layer is closed.
                  <br />
                  When the layer is open, <Prop.Ref>layerSide</Prop.Ref>{" "}
                  describes on which side the layer is currently positioned
                  relative to the trigger. <br />
                  When <Prop.Ref>layerSide</Prop.Ref> is <Prop.Str as="span">
                    "center"
                  </Prop.Str>, it means that the layer is anchored <Prop.Str as="span">
                    "CENTER"
                  </Prop.Str>
                  <br />
                  <Prop.Obj as="span">LayerSide</Prop.Obj> = <Prop.Str as="span">
                    "top"
                  </Prop.Str> | <Prop.Str as="span">"right"</Prop.Str> | <Prop.Str as="span">
                    "bottom"
                  </Prop.Str> |<Prop.Str as="span">"left"</Prop.Str> | <Prop.Str as="span">"center"</Prop.Str>
                </>
              }
            />
            <Prop
              name="arrowStyle"
              type={
                <>
                  <Prop.Obj>CSSProperties</Prop.Obj>
                </>
              }
              misc={
                <>
                  If you want to display an arrow-like element, which many
                  tooltip-like components do, you can utilize the{" "}
                  <Prop.Ref>arrowStyle</Prop.Ref>. This style object gives the
                  position of the center of the trigger, relative to the layer.
                  How you style your arrow further is up to you. You could use a
                  svg-element for instance, and calculate its rotation based on
                  the <Prop.Ref>layerSide</Prop.Ref> prop. Another possibility
                  is to inject the positions into a styled-component and use a{" "}
                  <Prop.Ref>&::before{"{}"}</Prop.Ref> selector
                </>
              }
            />
            <Prop
              name="triggerRect"
              type={
                <>
                  <Prop.Obj>ClientRect</Prop.Obj>
                </>
              }
              misc={
                <>
                  Useful if you want to style your layer according to the
                  trigger's width for instance.
                </>
              }
            />
            <Prop
              name="close()"
              type={<>(): void</>}
              misc={
                <>
                  Useful if you want to close the layer, from within the layer
                  itself. For instance, when a menu-item was clicked.
                </>
              }
            />
          </>
        }
      />
    </>
  }
/>

<p>
  A quick example to illustrate all provided{" "}
  <Prop.Obj>RenderLayerProp</Prop.Obj>'s:
</p>

```jsx
<ToggleLayer
  renderLayer={({ layerProps, isOpen, triggerRect, arrowStyle, close }) => {
    if (isOpen) {
      return (
        <div
          ref={layerProps.ref}
          className="layer"
          style={{
            ...layerProps.style,
            width: triggerRect.width
          }}
        >
          <div className="layer-arrow" style={arrowStyle} />

          <button onClick={close}>close</button>
        </div>
      );
    }

    return null;
  }}

  // rest of props skipped for brevity
/>
```

<Prop
  name="placement"
  type={<Prop.Obj>PlacementConfig</Prop.Obj>}
  misc={
    <>
      <Prop.TypeBox
        name="PlacementConfig"
        props={
          <>
            <Prop
              name="anchor"
              defaultValue={<Prop.Str>"TOP_CENTER"</Prop.Str>}
              type={<Prop.Obj>AnchorEnum</Prop.Obj>}
              misc={
                <>
                  Tells react-laag which anchor (location of the layer) you
                  prefer. <br />
                  <Prop.Str as="span">"CENTER"</Prop.Str> behaves a bit different
                  compared to the rest of the anchors, in that it centers both horizontally
                  and vertically, overlapping the trigger element. <br />
                  <br />
                  Possible values: <Prop.Str as="span">"TOP_LEFT"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"TOP_CENTER"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"TOP_RIGHT"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"BOTTOM_LEFT"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"BOTTOM_CENTER"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"BOTTOM_RIGHT"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"LEFT_TOP"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"LEFT_CENTER"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"LEFT_BOTTOM"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"RIGHT_TOP"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"RIGHT_CENTER"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"RIGHT_BOTTOM"</Prop.Str>
                  {" | "}
                  <Prop.Str as="span">"CENTER"</Prop.Str>
                </>
              }
            />
            <Prop
              name="possibleAnchors"
              type={<Prop.Obj>AnchorEnum[]</Prop.Obj>}
              defaultValue="All anchors"
              misc={
                <>
                  <Prop.Ref>possibleAnchors</Prop.Ref> has only effect when{" "}
                  <Prop.Ref>autoAdjust</Prop.Ref> is enabled. <br />
                  It describes which anchors should be considered when finding the
                  best suitable anchor to fit on the screen.
                </>
              }
            />
            <Prop
              name="autoAdjust"
              type={<Prop.Obj>boolean</Prop.Obj>}
              defaultValue={<Prop.Bool>false</Prop.Bool>}
              misc={
                <>
                  Determines whether react-laag should find another anchor when
                  the preferred one does not fit the current screen.
                  <br />
                  When <Prop.Ref>snapToAnchor</Prop.Ref> is set to{" "}
                  <Prop.Bool>false</Prop.Bool>, there will be a smooth
                  'sliding'-like effect from one anchor to the next.
                </>
              }
            />
            <Prop
              name="snapToAnchor"
              type={<Prop.Obj>boolean</Prop.Obj>}
              defaultValue={<Prop.Bool>false</Prop.Bool>}
              misc={
                <>
                  Determines whether the layer can place itself between to
                  anchors, creating a 'sliding'-effect when scrolling the
                  page/element. With <Prop.Ref>snapToAnchor</Prop.Ref> enabled,
                  the layer will 'jump' from one anchor to the next one
                  instantly.
                </>
              }
            />
            <Prop
              name="preferX"
              type={
                <>
                  <Prop.Str as="span">"LEFT"</Prop.Str> |{" "}
                  <Prop.Str as="span">"RIGHT"</Prop.Str>
                </>
              }
              defaultValue={<Prop.Str>"RIGHT"</Prop.Str>}
              misc={
                <>
                  Only has effect when <Prop.Ref>autoAdjust</Prop.Ref> is
                  enabled. <br />
                  Determines which side is preferred when the layer fits on both
                  the left and right side of the trigger.
                </>
              }
            />
            <Prop
              name="preferY"
              type={
                <>
                  <Prop.Str as="span">"TOP"</Prop.Str> |{" "}
                  <Prop.Str as="span">"BOTTOM"</Prop.Str>
                </>
              }
              defaultValue={<Prop.Str>"BOTTOM"</Prop.Str>}
              misc={
                <>
                  Only has effect when <Prop.Ref>autoAdjust</Prop.Ref> is
                  enabled. <br />
                  Determines which side is preferred when the layer fits on both
                  the top and bottom side of the trigger.
                </>
              }
            />
            <Prop
              name="triggerOffset"
              type={<Prop.Obj>number</Prop.Obj>}
              defaultValue={0}
              misc={
                <>
                  Determines the distance in pixels between the layer and the
                  trigger.
                </>
              }
            />
            <Prop
              name="scrollOffset"
              type={<Prop.Obj>number</Prop.Obj>}
              defaultValue={10}
              misc={
                <>
                  Determines the minimum margin in pixels between the layer and
                  the scroll-containers (incl. viewport)
                </>
              }
            />
            <Prop
              name="layerDimensions"
              type={
                <>
                  {"{"} <Prop.Arg>width</Prop.Arg>: <Prop.Obj>number</Prop.Obj>,{" "}
                  <Prop.Arg>height</Prop.Arg>: <Prop.Obj>number</Prop.Obj> {"}"}{" "}
                  | ( <Prop.Arg>layerSide</Prop.Arg>:{" "}
                  <Prop.Obj>LayerSide</Prop.Obj> ): {"{"}{" "}
                  <Prop.Arg>width</Prop.Arg>: <Prop.Obj>number</Prop.Obj>,{" "}
                  <Prop.Arg>height</Prop.Arg>: <Prop.Obj>number</Prop.Obj> {"}"}
                </>
              }
              misc={
                <>
                  Sometimes your layer needs a different width and / or height
                  based on certain conditions, ie. on which side the layer is
                  relative to the trigger-element. react-laag needs to
                  anticipate these conditional dimensions on order to find the
                  best suitable place to render the layer. Otherwise, react-laag
                  will 'see' the layer's dimensions only after it has been
                  re-positioned, which may result in an infinite loop of
                  positional calculations.
                </>
              }
            />
          </>
        }
      />
    </>
  }
/>

<Prop
  name="fixed"
  type={<Prop.Obj>boolean</Prop.Obj>}
  defaultValue={<Prop.Bool>false</Prop.Bool>}
  misc={
    <>
      By default react-laag tries to render the layer within the closest
      scroll-container. But in some cases you want the layer to show outside
      its parent scroll-container. This is especially true for tooltip-like
      components. It's called 'fixed'-mode, because instead of positioning the
      layer absolute, relative to its parent, the layer gets positioned fixed
      against the viewport.
      <br />
      <br />
      Note: Only the viewport boundaries are taken into account when using <Prop.Ref>
        placement.autoAdjust
      </Prop.Ref>.
    </>
  }
/>
<Prop
  name="isOpen"
  type={<Prop.Obj>boolean</Prop.Obj>}
  misc={
    <>
      By setting the <Prop.Ref>isOpen</Prop.Ref> prop, you are controlling when the layer should show or not. <br />
      This also means that trying to call the <Prop.Ref>open()</Prop.Ref>, <Prop.Ref>close()</Prop.Ref> and <Prop.Ref>toggle()</Prop.Ref> functions from the children-props, will result in an error being thrown.
    </>
  }
/>
<Prop
  name="onStyle()"
  type={
    <>
      ( <Prop.Arg>layerStyle</Prop.Arg>: <Prop.Obj>CSSProperties</Prop.Obj>, <Prop.Arg>arrowStyle</Prop.Arg>: <Prop.Obj>CSSProperties</Prop.Obj>, <Prop.Arg>layerSide</Prop.Arg>: <Prop.Obj>LayerSide</Prop.Obj>): void
    </>
  }
  misc={
    <>
      By passing <Prop.Ref>onStyle</Prop.Ref> you get control over how the relevant elements are styled. This is an advanced feature, and should generally only be used when necessary. A reason to control the styles yourself, is when you run into performance issues because your layer/trigger is expensive to render, and you want to update the styles without causing React to re-render.
      <br />
      Note: by using this prop you will receive no further style updates via the <Prop.Ref>renderLayer</Prop.Ref> prop when things like the layer's anchor has changed.
    </>
  }
/>
<Prop
  name="closeOnOutsideClick"
  type={<Prop.Obj>boolean</Prop.Obj>}
  misc={
   <>
    By setting this flag, react-laag will close the layer when a click has ocurred somewhere except the layer / trigger.
   </>
  }
/>
<Prop
  name="onOutsideClick()"
  type={<>(): void</>}
  misc={
   <>
    By using this prop, react-laag will notify you when a click has ocurred somewhere except the layer / trigger. Useful in combination with <Prop.Obj>isOpen</Prop.Obj>.
   </>
  }
/>
<Prop
  name="closeOnDisappear"
  type={<>undefined | <Prop.Str as="span">"partial"</Prop.Str> | <Prop.Str as="span">"full"</Prop.Str></>}
  misc={
   <>
    The behavior depends on whether <Prop.Ref>fixed</Prop.Ref> is set to true or false: <br /><br />
    In <strong>fixed</strong> mode, the layer will close when the <strong>trigger</strong> has fully / partially disappeared. <br />
    In <strong>non-fixed</strong> mode, the layer will close when the <strong>layer</strong> has fully / partially disappeared. <br />
   </>
  }
/>
<Prop
  name="onDisappear()"
  type={<>( <Prop.Arg>type</Prop.Arg>: <Prop.Str as="span">"partial"</Prop.Str> | <Prop.Str as="span">"full"</Prop.Str> ): void</>}
  misc={
   <>
    By using this prop, react-laag will notify you when: <br />
    - in <strong>fixed</strong> mode, and the <strong>trigger</strong> has fully / partially disappeared. <br />
    - in <strong>non-fixed</strong> mode, and the <strong>layer</strong> has fully / partially disappeared. <br />
   </>
  }
/>
<Prop
  name="ResizeObserver"
  type={<Prop.Obj>ResizeObserver</Prop.Obj>}
  misc={
    <>
      Use this prop to inject a ResizeObserver polyfill for browsers that have
      no support out of the box.
    </>
  }
/>
<Prop
  name="container"
  experimental
  type={<><Prop.Obj>HTMLElement</Prop.Obj> | (): <Prop.Obj>HTMLElement</Prop.Obj></>}
  misc={
    <>
      Normally, react-laag renders the layers inside the closest scroll-parent. However, there might be use-cases where you want to control in which container the layers are rendered in. Since react-laag (in non-fixed mode) looks at the <Prop.Ref>scrollTop</Prop.Ref> and <Prop.Ref>scrollLeft</Prop.Ref> properties of the scroll-parent for positioning, it is advised to also put the container element inside the the same scroll-parent as the layer. It is possible to place the container element outside of the scroll-parent, but that will only work in 'fixed' mode. <br/>
      Note: for elements that are part of the React render tree, it is recommended to pass a getter function which returns a reference to the element, because it could be that the element has not been mounted by React yet. For containers defined in an 'index.html' for example, a <Prop.Ref>document.getElementById</Prop.Ref> will suffice.
    </>
}
/>

# useToggleLayer()

Hook variant of `<ToggleLayer />` that tries to achieve the same thing: rendering layers. When using `<ToggleLayer />`, the layer is coupled tightly to the trigger element, but there are cases where the trigger element is unknown beforehand, or there simply isn't a trigger-element (but another source to tie the layer to). In such cases it is recommended to use `useToggleLayer()`.

Common use cases: _context-menu's_, _text-selection_.

```jsx
import { useToggleLayer } from "react-laag";
```

<Prop.Label>Type</Prop.Label>
<Prop.Type>
  (<br/><Prop.Arg style={{ marginLeft: 24}}>renderLayer</Prop.Arg>: ( <Prop.Arg>props</Prop.Arg>: <Prop.Obj linked>RenderLayerProps</Prop.Obj>{" "}): <Prop.Obj>ReactNode</Prop.Obj>,<br/><Prop.Arg style={{ marginLeft: 24}}>options?</Prop.Arg>: <Prop.Obj linked>Options</Prop.Obj><br/>): [
  <Prop.Obj>ReactNode</Prop.Obj>, <Prop.Obj linked>ToggleLayerProps</Prop.Obj>]
</Prop.Type>
<Prop.TypeBox
  name="RenderLayerProps"
  props={<>See <Prop.Ref>ToggleLayers</Prop.Ref>'s <Prop.Ref>renderLayer</Prop.Ref> prop for more info.</>}
/>
<Prop.TypeBox
  name="Options"
  props={<>Same props as <Prop.Ref>ToggleLayers</Prop.Ref>, except for <Prop.Ref>isOpen</Prop.Ref>, <Prop.Ref>onOutsideClick()</Prop.Ref> and <Prop.Ref>onDisappear()</Prop.Ref></>}
/>
<Prop.TypeBox
  name="ToggleLayerProps"
  props={
    <>
<Prop
              name="isOpen"
              type={<Prop.Obj>boolean</Prop.Obj>}
              misc="Describes whether the layer is open or closed"
            />
            <Prop
              name="open()"
              type={<>(<Prop.Arg>props</Prop.Arg>: {"{"} <Prop.Arg>clientRect</Prop.Arg>: <Prop.Obj>ClientRect</Prop.Obj> | (): <Prop.Obj>ClientRect</Prop.Obj>; <Prop.Arg>target</Prop.Arg>: <Prop.Obj>HTMLElement</Prop.Obj> {"}"}): void</>}
              misc={
                <>
                  Shows the layer.<br/>
                  The <Prop.Ref>clientRect</Prop.Ref> prop is used to position the layer. Provide a function returning a <Prop.Obj>ClientRect</Prop.Obj> if you want react-laag to re-position the layer on scrolling / resizing.<br/>
                  The <Prop.Ref>target</Prop.Ref> prop is used to determine where to place the layer in the DOM.
                </>
              } />
            <Prop
              name="openFromMouseEvent()"
              type={<>(<Prop.Arg>event</Prop.Arg>: <Prop.Obj>MouseEvent</Prop.Obj>): void</>}
              misc={
                <>
                  Utility method that shows the layer with a mouse event as its source.
                </>
              } />
            <Prop
              name="openFromContextMenuEvent()"
              type={<>(<Prop.Arg>event</Prop.Arg>: <Prop.Obj>MouseEvent</Prop.Obj>): void</>}
              misc={
                <>
                  Utility method that shows the layer with a context-menu-event as its source.
                </>
              } />
            <Prop name="close()" type={<>(): void</>} misc="Hides the layer" />
            <Prop
              name="layerSide"
              type={
                <>
                  <Prop.Obj>LayerSide</Prop.Obj> | <Prop.Obj>null</Prop.Obj>
                </>
              }
              misc={
                <>
                  <Prop.Ref>null</Prop.Ref> when the layer is closed.
                  <br />
                  When the layer is open, <Prop.Ref>layerSide</Prop.Ref>{" "}
                  describes on which side the layer is currently positioned
                  relative to the trigger. <br />
                  When <Prop.Ref>layerSide</Prop.Ref> is <Prop.Str as="span">
                    "center"
                  </Prop.Str>, it means that the layer is anchored <Prop.Str as="span">
                    "CENTER"
                  </Prop.Str>
                  <br />
                  <Prop.Obj as="span">LayerSide</Prop.Obj> = <Prop.Str as="span">
                    "top"
                  </Prop.Str> | <Prop.Str as="span">"right"</Prop.Str> | <Prop.Str as="span">
                    "bottom"
                  </Prop.Str> |<Prop.Str as="span">"left"</Prop.Str> | <Prop.Str as="span">"center"</Prop.Str>
                </>
              }
            />
    </>
  }
/>

### Example

```jsx
function HookExample() {
  const [element, toggleLayerProps] = useToggleLayer(
    // determine how to render the layer
    ({ isOpen, layerProps }) => isOpen && <div {...layerProps} />,
    // optionally provide options
    {
      placement: {
        anchor: "BOTTOM_CENTER",
        autoAdjust: true,
        snapToAnchor: true,
        triggerOffset: 12,
        scrollOffset: 16,
        possibleAnchors: [
          "BOTTOM_CENTER",
          "LEFT_CENTER",
          "RIGHT_CENTER",
          "TOP_CENTER"
        ]
      },
      closeOnOutsideClick: true
    }
  );

  // react to events
  return <div onContextMenu={toggleLayerProps.openFromContextMenuEvent}></div>;
}
```

# useHover()

When working with tooltips for instance, you sometimes want specific behavior regarding timing. If you show a tooltip immediately when the mouse enters the trigger element, the user may perceive the tooltip as annoying. That's why it's common to only show a tooltip after a certain time has passed while the user has been hovering over the trigger element. `useHover` is a hook which helps you control this kind of behavior.

```jsx
import { useHover } from "react-laag";
```

<Prop.Label>Type</Prop.Label>
<Prop.Type>
  ( <Prop.Arg>config</Prop.Arg>?: <Prop.Obj>UseHoverConfig</Prop.Obj> ): [
  <Prop.Obj>boolean</Prop.Obj>, <Prop.Obj>HoverProps</Prop.Obj>]
</Prop.Type>
<Prop.TypeBox
  name="UseHoverConfig"
  props={
    <>
      <Prop
        name="delayEnter"
        type={<Prop.Obj>number</Prop.Obj>}
        defaultValue={0}
        misc={"Amount of time in ms that should pass while hovering in order to show the layer"}
      />
      <Prop
        name="delayLeave"
        type={<Prop.Obj>number</Prop.Obj>}
        defaultValue={0}
        misc={"Amount of time in ms that should pass while user has left the element before the layer hides again"}
      />
    </>
  }
/>
<Prop.TypeBox
  name="HoverProps"
  props={
    <>
      <Prop
        name="onMouseEnter"
        type={<>(): void</>}
      />
      <Prop
        name="onMouseLeave"
        type={<>(): void</>}
      />
    </>
  }
/>

Example:

```jsx
function UseHoverExample() {
  const [show, hoverProps] = useHover({ delayEnter: 300, delayLeave: 200 });

  return (
    <ToggleLayer
      isOpen={show}
      renderLayer={({ layerProps }) =>
        isOpen ? <Layer {...layerProps} /> : null
      }
      // rest of props...
    >
      {({ triggerRef }) => (
        <div ref={triggerRef} {...hoverProps}>
          hover me!
        </div>
      )}
    </ToggleLayer>
  );
}
```

# < Arrow />

`<Arrow />` is a utility component that is useful if you want to add an arrow to your layer. This is a common practice for especially tooltips, as well as menu's. The `<Arrow />` component composes a svg dynamically based on a couple of props you provide. The goal is to add arrow functionality in a declarative way, without the need to do any arrow specific calculations.

```jsx
import { Arrow } from "react-laag";
```

## Props

<Prop
  name="layerSide"
  type={
    <>
      <Prop.Obj>LayerSide</Prop.Obj>
    </>
  }
  defaultValue={"top"}
  misc={<>Determines which side the layer is currently on. This property is normally provided as part of the <Prop.Obj>RenderLayerProps</Prop.Obj>.</>}
/>
<Prop
  name="style"
  type={
    <>
      <Prop.Obj>CSSProperties</Prop.Obj>
    </>
  }
  defaultValue={"top"}
  misc={<>Style that positions the arrow. This property (`arrowStyle`) is normally provided as part of the <Prop.Obj>RenderLayerProps</Prop.Obj>.</>}
/>
<Prop
  name="size"
  type={
    <>
      <Prop.Obj>number</Prop.Obj>
    </>
  }
  defaultValue={8}
  misc={<>Distance in pixels between point of the arrow and the layer</>}
/>
<Prop
  name="angle"
  type={
    <>
      <Prop.Obj>number</Prop.Obj>
    </>
  }
  defaultValue={45}
  misc={<>Angle of the point of the arrow in degrees. Accepts a value between 0-80, where a lower value results in a more pointy arrow.</>}
/>
<Prop
  name="roundness"
  type={
    <>
      <Prop.Obj>number</Prop.Obj>
    </>
  }
  defaultValue={0}
  misc={<>Value between 0 and 1. Determines how 'sharp' the point of the arrow should be, much like the 'border-radius' in css.</>}
/>
<Prop
  name="borderWidth"
  type={
    <>
      <Prop.Obj>number</Prop.Obj>
    </>
  }
  defaultValue={0}
  misc={<>The width of the border</>}
/>
<Prop
  name="borderColor"
  type={
    <>
      <Prop.Obj>string</Prop.Obj>
    </>
  }
  defaultValue={"black"}
  misc={<>The color of the border</>}
/>
<Prop
  name="backgroundColor"
  type={
    <>
      <Prop.Obj>string</Prop.Obj>
    </>
  }
  defaultValue={"white"}
  misc={<>The background-color of the arrow</>}
/>

## Example

```jsx
import * as React from "react";
import { ToggleLayer, Arrow } from "react-laag";

<ToggleLayer
  renderLayer={({ layerProps, layerSide, arrowStyle }) =>
    isOpen && (
      <div {...layerProps}>
        <Arrow
          style={arrowStyle}
          layerSide={layerSide}
          size={8}
          angle={45}
          roundness={1}
          borderWidth={1}
          borderColor="black"
          backgroundColor="white"
        />
      </div>
    )
  }
>
  {({ triggerRef, toggle }) => (
    <button ref={triggerRef} onClick={toggle}>
      Toggle
    </button>
  )}
</ToggleLayer>;
```

# < Transition />

Utility component that lets you transition the appearance / disappearance of the layer in a simple way. Best used if you want to use simple css-transitions like `opacity` or `transform` and don't want to depend on an animation library. For more complex transitions it is recommended to use tools like `framer-motion` or `react-spring`.

```jsx
import { Transition } from "react-laag";
```

<Prop
  name="isOpen"
  type={
    <>
      <Prop.Obj>boolean</Prop.Obj>
    </>
  }
  required
  misc={<>Determines if the layer is currently open or closed.</>}
/>
<Prop
  name="children()"
  type={
    <>
      ( <Prop.Arg>isOpen</Prop.Arg>: <Prop.Obj>boolean</Prop.Obj>, <Prop.Arg>onTransitionEnd</Prop.Arg>: <Prop.Obj>() => void</Prop.Obj>, <Prop.Arg>isLeaving</Prop.Arg>: <Prop.Obj>boolean</Prop.Obj> ):{" "}
      <Prop.Obj>ReactNode</Prop.Obj>
    </>
  }
  required
/>

```jsx
import * as React from "react";
import { ToggleLayer, Transition } from "react-laag";

<ToggleLayer
  renderLayer={({ isOpen, layerProps }) => (
    <Transition isOpen={isOpen}>
      {(isOpen, onTransitionEnd) => (
        <div
          ref={layerProps.ref}

          // `onTransitionEnd` is required in order for `<Transition />`
          // to determine when the layer should be unmounted.
          onTransitionEnd={onTransitionEnd}
          style={{
            ...layerProps.style,
            // `transition` is required for the `onTransitionEnd` to fire
            transition: '0.2s ease-in-out'

            // declare styles based on whether the layer is open or closed
            opacity: isOpen ? 1 : 0
          }}
        >
          Layer
        </div>
      )}
    </Transition>
  )}
>
  {({ triggerRef, toggle }) => (
    <button ref={triggerRef} onClick={toggle}>
      Toggle
    </button>
  )}
</ToggleLayer>;
```

# Tutorials

- [Introducing react-laag](https://www.erikverweij.dev/blog/introducing-react-laag/)
- [Circular menu's with react-laag and Framer Motion](https://www.erikverweij.dev/blog/circular-menus-with-react-laag-framer-motion/)

# Recipes

## Circular menu

https://codesandbox.io/s/circular-menu-autoadjust-m9zi5?hidenavigation=1&view=preview

## Popover menu

https://codesandbox.io/s/popover-menu-bvplm?hidenavigation=1&view=preview

## Tooltip

https://codesandbox.io/s/tooltip-pt2en?hidenavigation=1&view=preview

## Nested context menu's

https://codesandbox.io/s/nested-context-menus-xx52d?hidenavigation=1&view=preview

## Input validation

https://codesandbox.io/s/password-270o7?hidenavigation=1&view=preview

## Autocomplete with Downshift

https://codesandbox.io/s/downshift-rw4hb?hidenavigation=1&view=preview

## Boxes with color picker menu

https://codesandbox.io/s/color-picker-boxes-853ix?hidenavigation=1&view=preview

## DraftJS text selection menu

https://codesandbox.io/s/draftjs-text-selection-5ru5r?hidenavigation=1&view=preview

## Animations

### framer-motion

https://codesandbox.io/s/framer-motion-hgkm4?hidenavigation=1&view=preview

### react-spring

https://codesandbox.io/s/react-spring-nb6h3?hidenavigation=1&view=preview
